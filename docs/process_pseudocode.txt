Step 1. Input Data Quality Assessment

Import required python modules

------------------------------------------------------------------------------------------------------------------------------------------------

Step 2. Clean / Standardize Data  (clean_data.py)

* WILL DIFFER BASED ON SOURCE DATA STRUCTURE WILL NOT BE CONSISTENT PROVINCE BY PROVINCE *

Import required python modules

Set working_prov variable to work area

Set proj_crs variable to to the 'working prov'_CRS variable in the environments file

Load in path to address points layer and assign to the variable ap_path

Create a list of fields in the address points layer that contain the address information
and assign to the ap_add_fields variable

Load in the path to the linking data path from the environments file and assign it to the 
linking_data_path variable

Load in the list of linking fields to ignore

Load in roads data assign to rd_gpkg and rd_lyr_nme variables
Load the list of fields from the road layer to use in the analysis and assign to the variable rd_use_flds

If needed load in the area of interest polygon and assign to the variable aoi_mask

Load in the gpkg for outputs datasets and assign to the variable project_pgkg

Create a dictionary of road name corrections specific to the road dataset and assign to the vaiable type_corr_dict

Create a list of all possible road types and assign to the variable master_types

Load the linking data into a geodataframe filtering out all unneeded columns and assihn to the variable linking_data
In linking_data create a new interger field called 'link_field' with each record containing a unique value 
Project linking_data into the project CRS

Export linking_data to the project_gpkg with the layer name 'parcels_cleaned'

Read the adress data into a geodataframe and assign to the variable addresses
Project addresses into the project CRS

Perform a spatial join between addresses and linking_data to add 'link_field' to addresses

Clean and standardize the address component fields in addresses and assign to the fields 'suffix', 'number', 'street'

Export addresses as a layer in the project_gpkg with the layer name 'addresses_cleaned'

Load the raod data into geodataframe and assign to the variable roads
Set the crs for roads to match the project dataframe

Filter out certain types of roads that are not needed such as Winter, Unknown, etc

Clean and standardize the street name components and assign to the appropriate variables

Drop uneeded coulmns from roads

Export roads to the project_gpkg with the layer name 'roads_cleaned'

Load the footprints data into a geodataframe and assign to the variable footprint apply aoi_mask if needed

Calculate the area of each footprint and assign to the field 'area'
Drop all buildings with an area of less than 20 meters squared
Ensure that the crs of footprints matches the proj_crs

Get the centroid geometry of each footprint and assign to the field 'centroid_geo'in footprint geodataframe
Set the geometry of the geodataframe to the field 'centroid_geo'

Perform a spatial join between the footprint geodataframe and linking data to add the 'link_field' to the footprint data

Reset the geometry to the golygon geometry and delete the 'centroid_geo' field from the the footprints geodataframe

Export export the footprint geodataframe to the project_gpkg with the layer name 'footprints_cleaned'

---------------------------------------------------------------------------------------------------------------------------------------------

Step 3. Match Data (matching_master.py)

Import required python modules

# INITIAL VARIABLE LOADS

Load in project geopackage path and assign it to the variable project_gpkg

Load in the cleaned footprints layer name from the environments and assign it to the variable footprints_lyr_nme

Load in the cleaned address points layer name from the environments and assign it to the variable footprints_lyr_nme

Set proj_crs variable to to the 'working prov'_CRS variable in the environments file

Load in the name of the field that contains the address number info in the address layer from the environment file and assign it to the add_num_fld_nme variable

Load the name of the unlinked building footprint layer from the environments file and assign it to the variable 
unlinked_bf_lyr_nme

# STEP 1

Load the address point data into a geodataframe and assign to the variable addresses
Load the building footprint data into a geodataframe and assign to the variable foorprint

Set the crs of the address variable to the proj_crs variable
Set the crs of the footprint variable to the proj_crs variable

Define the join fields for the footprint and addresses datasets and assign to the variables join_footprint and join_addresses

# STEP 2

Create a new field in the addresses geodataframe called 'addresses_index' and assign it the values from the existing index field
Create a new field in the footprint geodataframe called 'footprint_index' and assign it the values from the existing index field

Merge the link_addresses field and the addresses_index field from the address geodatabase to the footprint geodataframe and assign to the variable merge

In the merge geodataframe group all new linkages from the link_addresses field into a list and add them to the footprints geodataframe in the addresses_index field

Drop the footprint_index field from the footprint geodataframe

Extract all building footprints that do not have a linkage and assign as a new geodataframe to the variable unlinked_bfs

Drop all records from the footprints geodataframe that do not have a linkage

if there are any records in unlinked_bfs:
    Drop the addresses_index field from unlinked_bfs
    Convert unlinked_bfs so the crs matches proj_crs
    For each footprint in unlinked_bfs:
        Iterate over the buffer_distances variable in increasing distance:
            Create buffer geometry around the builkding footprint at the given distance
            Check for address points that intersect the buffer geometry
            If a match is found break loop and add the indexes to the address_index field in the unlinked_bfs geodataframe 
            Assign the 'method' field for that footprint to equal the buffer distance in meters
            Else continue to the next distance in buffer_distances until a match is found or the maximum buffer distance is reached
    
    Append the unlinked_bfs geodataframe to the footprint geodataframe


# STEP 3 

Add a new field to the footprint dataframe called intersect_index and assign it a value under the following conditions
    For each footprint in the footprints geodataframe:
        Filter the addresses geodataframe by the address_index field in the footprints geodataframe
        Check to see if any of the address points intersect the building foorprint
        If True then return the address_index value and assign to the intersect_index field

Create a new geodataframe for all records in footprints where 'intersect_index' is not null and assign it to a variable called intersections

In the footprints geodataframe filter out all records where 'intersect_index' is not null

Drop the 'intersect_index field' in the footprints geodataframe

Create a list of all intersect indexes from the intersections geodatabase and assign it to the variable intersect_indexes

Create a list of footprints that have points intersecting them and assign to the variable intersect_footprints

Drop all rows without a value in the 'addresses_index' field in the  footprint geodataframe

Ensure that the 'intersect_index' field is typed as integer

Create the 'addresses_index' field in the indersections geodataframe and assign it the values in the 'intersect_index' field
Drop the 'intersect_index' field in the intersections geodataframe
Create the 'method' field in the intersections geodataframe and assign it the value 'intersect'

# STEP 4

Ensure that the CRS for the intersections, addresses and fotprint geodataframes all match proj_crs

Convert 'addresses_index' in the footprints geodataframe from integer(s) to a tuple if possible

Create a subset of the 'addresses_index' field in the footprints geodataframe where the length of thie field is greater than 1 assign this subset to the variable flag_plural

For each footprint in the footprint geodataframe with an index in flag_plural: 
    Determine the point that is closest to the footprint and create a match:
    Extract the geometry of all points whose index is contained in the footprints 'addresses_index' field
    Determine the distance from the point to the footprint for each point and assign to distance_values
    If the length of distance_values is 0:
        Assign a NULL value to the address_index
    Determine the minimum value in distance_values and assign the index for that value to the 'addresses_index' for the footprint

Drop buildings with a NULL 'address_index' value from the footprint geodataframe
Ensure all values in the 'addresses_index' are integers
Fill the 'method' field for all records matched through data linking with the value data_linking

# STEP 5

Append thr intersections geodataframe to the footprint geodataframe and assign this to a variable named outgdf

Export outgdf as a layer called 'footprint_linkages' in the output_gpkg

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Step 4. Assess Match Quality (buisness_rules.py)

Import required python modules

...
